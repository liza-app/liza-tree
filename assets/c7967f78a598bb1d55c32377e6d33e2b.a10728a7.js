import{u as e,d as l}from"./index.2b004346.js";import{_ as d}from"./DocTemplateBase.3230dea8.js";import{h as n,I as t,k as o,v as a,n as r,t as i,p as u,w as p,z as s,W as c}from"./vendor.92220208.js";const g={extends:d,setup(){const d=t(),o=[{name:"安装",id:"安装",children:[]},{name:"引入",id:"引入",children:[]},{name:"不要给节点设置外边距",id:"不要给节点设置外边距",children:[]},{name:"treeData 或 flatData",id:"treedata-或-flatdata",children:[]},{name:"HTML 结构",id:"html-结构",children:[]},{name:"使用",id:"使用",children:[]},{name:"输出数据",id:"输出数据",children:[]},{name:"折叠和展开",id:"折叠和展开",children:[]},{name:"按需加载子节点",id:"按需加载子节点",children:[]},{name:"默认折叠所有节点",id:"默认折叠所有节点",children:[]},{name:"勾选框",id:"勾选框",children:[]},{name:"RTL",id:"rtl",children:[]},{name:"虚拟列表",id:"虚拟列表",children:[]},{name:"拖拽",id:"拖拽",children:[]},{name:"拖拽触发",id:"拖拽触发",children:[]},{name:"阻止拖拽",id:"阻止拖拽",children:[]},{name:"阻止放入",id:"阻止放入",children:[]},{name:"拖拽过程中的运行时数据",id:"拖拽过程中的运行时数据",children:[]},{name:"占位元素",id:"占位元素",children:[]},{name:"拖拽到节点上时打开该节点",id:"拖拽到节点上时打开该节点",children:[]},{name:"拖拽节点的定位",id:"拖拽节点的定位",children:[]},{name:"边缘滚动",id:"边缘滚动",children:[]},{name:"触摸",id:"触摸",children:[]},{name:"最大层级",id:"最大层级",children:[]},{name:"Pro 插件(需购买)",id:"pro-插件需购买",children:[]},{name:"通过 script 标签引入",id:"通过-script-标签引入",children:[]}];e("Guide",d),l.value=o,n((()=>{l.value=null}))}},f={class:"docs-view"},v={class:"article mt-14 mb-8 prose"},h=s("Guide"),m=i("p",null,[i("strong",null,"使用 Vue2 时把下面文档的 3 替换为 2.")],-1),x=s("安装"),D=i("pre",null,[i("code",{class:"language-sh"},"# Vue3\nnpm i -P @he-tree/vue3\n# Vue2\nnpm i -P @he-tree/vue2\n")],-1),_=s("引入"),q=i("pre",null,[i("code",{class:"language-ts"},"import { BaseTree, Draggable, obj, BaseNode, Node } from '@he-tree/vue3'\nimport '@he-tree/vue3/dist/he-tree-vue3.css'\n")],-1),y=s("不要给节点设置外边距"),T=i("p",null,[s("你可能需要设置节点之间的距离, 不要使用"),i("code",null,"margin-bottom"),s("来实现. 否则组件不能得到节点的真实高度. 使用 prop "),i("code",null,"gap"),s(" 替代.")],-1),b=s("treeData 或 flatData"),$=c('<p>该组件可以传入树形数据或扁平数据. 传入树形数据(treeData)时, 需指定 <code>childrenKey</code>. 传入扁平数据(flatData)时, 需指定 <code>idKey</code>, <code>parentIdKey</code>.</p><p><code>treeData</code> 示例:</p><pre><code class="language-ts">treeData = [\n  {\n    text: &#39;node1&#39;,\n    children: [{ text: &#39;node1-1&#39; }, { text: &#39;node1-2&#39; }, { text: &#39;node1-3&#39; }],\n  },\n  { text: &#39;node2&#39; },\n]\n</code></pre><p><code>flatData</code> 示例:</p><pre><code class="language-ts">flatData = [\n  { text: &#39;node1&#39;, id: 1 },\n  { text: &#39;node2&#39;, id: 2 },\n  { text: &#39;node1-1&#39;, id: 3, pid: 1 },\n  { text: &#39;node1-2&#39;, id: 3, pid: 1 },\n  { text: &#39;node1-3&#39;, id: 3, pid: 1 },\n]\n</code></pre>',5),N=s("HTML 结构"),B=c('<pre><code class="language-pug">.he-tree(:id=&quot;treeID&quot; :class=&quot;{&#39;he-tree-dragging&#39;:dragging, &#39;he-tree-rtl&#39;: rtl}&quot;)\n  .vl-items\n    .tree-node-outer(:data-id=&quot;node.$id&quot; :class=&quot;node.$outerClass&quot; :style=&quot;node.$outerClass&quot;)\n      .tree-node(:class=&quot;node.$nodeClass&quot; :style=&quot;node.$nodeStyle&quot;)\n        slot(:node=&quot;node&quot; :tree=&quot;tree&quot;) {{node[textKey]}}\n    .tree-node-outer(:data-id=&quot;node.$id&quot; :class=&quot;node.$outerClass&quot; :style=&quot;node.$outerClass&quot;)\n      .tree-node(:class=&quot;node.$nodeClass&quot; :style=&quot;node.$nodeStyle&quot;)\n        slot(:node=&quot;node&quot; :tree=&quot;tree&quot;) {{node[textKey]}}\n    ...\n</code></pre><p><strong>该组件渲染为列表而不是树形结构. 不同层级的节点有不同的 <code>padding-left</code>.</strong> 参考此结构, 你可以做下面的事:</p><ul><li>设置 <code>node.$outerClass</code> 和 <code>node.$outerStyle</code>来控制 tree-node-outer 元素 的 class 和 style.</li><li>设置 <code>node.$nodeClass</code> 和 <code>node.$nodeStyle</code>来控制 tree-node 元素 的 class 和 style.</li><li>使用默认插槽来定制节点外观. 该插槽参数: node, tree.</li></ul>',3),L=s("使用"),M=i("pre",null,[i("code",{class:"language-vue"},"<template>\n  <BaseTree :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\" />\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { BaseTree } from '@he-tree/vue3'\n\n  export default {\n    components: { BaseTree },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n")],-1),S=s("输出数据"),K=s("使用方法 "),C=i("code",null,"outputNestedData",-1),H=s(" 和 "),V=i("code",null,"outputFlatData",-1),j=s(" 以获得树形数据或扁平数据. 在拖拽时为了获得改变后的数据, 可以在"),P=i("code",null,"drop",-1),k=s(" 或 "),I=i("code",null,"drop-change",-1),z=s("事件中执行它们."),F=s("折叠和展开"),W=i("pre",null,[i("code",{class:"language-vue"},"<template>\n  <BaseTree :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\">\n    <template v-slot=\"{ node, tree }\">\n      <b @click=\"tree.toggleFold(node)\">{{ node.$folded ? '+' : '-' }}</b>\n      <span>{{ node.text }}</span>\n    </template>\n  </BaseTree>\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { BaseTree } from '@he-tree/vue3'\n\n  export default {\n    components: { BaseTree },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n")],-1),w=s("按需加载子节点"),A=i("p",null,[s("展开节点时加载其子节点数据. 例如通过 Ajax. 使用 prop "),i("code",null,"childrenLazyLoading"),s(" 启用. prop "),i("code",null,"childrenLoader"),s(" 是加载时调用的方法, 可以返回 "),i("code",null,"Promise"),s(", 返回的数据只能是树形数据.")],-1),G=s("默认折叠所有节点"),R=i("p",null,[s("使用 prop "),i("code",null,"defaultFolded"),s(" 控制.")],-1),E=s("勾选框"),J=i("p",null,[s("使用方法 "),i("code",null,"getAllCheckedNodes"),s(" 以获得所有勾选的节点.")],-1),O=i("pre",null,[i("code",{class:"language-vue"},"<template>\n  <BaseTree :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\">\n    <template v-slot=\"{ node, tree }\">\n      <input\n        type=\"checkbox\"\n        v-model=\"node.$checked\"\n        @change=\"tree.updateChecked(node)\"\n      />\n      <span>{{ node.text }}</span>\n    </template>\n  </BaseTree>\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { BaseTree } from '@he-tree/vue3'\n\n  export default {\n    components: { BaseTree },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n")],-1),Q=s("RTL"),U=i("p",null,[s("从右到左显示. 使用 prop "),i("code",null,"rtl"),s(" 控制.")],-1),X=s("虚拟列表"),Y=i("p",null,[s("此功能可以在有许多节点时提高渲染性能. 使用 prop "),i("code",null,"virtualization"),s(" 启用. 使用 prop "),i("code",null,"virtualizationPrerender"),s(" 设置开始时显示的节点数量.")],-1),Z=s("拖拽"),ee=i("pre",null,[i("code",{class:"language-vue"},"<template>\n  <Draggable :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\" />\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { Draggable } from '@he-tree/vue3'\n\n  export default {\n    components: { Draggable },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n")],-1),le=s("拖拽触发"),de=i("p",null,[s("使用 prop "),i("code",null,"triggerClass"),s(" 指定触发拖拽的元素的 css class. 当 prop "),i("code",null,"triggerBySelf"),s(" 为 true 时, 它的子元素将不能触发拖拽.")],-1),ne=s("阻止拖拽"),te=c("<ul><li>当 prop <code>draggable</code> 为 false, 此树的任一节点不能被拖拽.</li><li>使用 prop <code>eachDraggable</code> 在拖拽开始时.</li><li>当 prop <code>rootDraggable</code> 为 false, 顶级节点(level 1) 不能被拖拽.</li><li>使用 prop <code>ondragstart</code> 在拖拽开始时.</li><li>设置 <code>node.$draggable</code> 为 false 控制单个节点是否可拖拽.</li><li>当父节点不可拖拽而子节点可拖拽时, 例如设置 子节点的 <code>$draggable</code> 为 true, 子节点可以拖拽.</li></ul>",1),oe=s("阻止放入"),ae=c("<ul><li>当 prop <code>droppable</code> 为 false, 任一节点不能放入这棵树.</li><li>使用 prop <code>eachDroppable</code> 当拖动到一节点上时.</li><li>当 prop <code>rootDroppable</code> 为 false, 被拖拽的节点不能成为顶级节点.</li><li>使用 prop <code>ondragend</code> 在拖拽结束时, 若返回 false, 则恢复拖拽前的原状. 支持 promise.</li><li>设置 <code>node.$droppable</code> 为 false 控制单个节点是否可放入.</li><li>当父节点不可放入而子节点可放入时, 例如设置子节点的 <code>$droppable</code> 为 true, 则此子节点可放入.</li></ul>",1),re=s("拖拽过程中的运行时数据"),ie=s("参考 "),ue=i("code",null,"tree.store",-1),pe=s("占位元素"),se=i("p",null,[s("拖拽时, 会生成一个元素默认淡青色背景, 用以标识可放置的位置. 使用 prop "),i("code",null,"afterPlaceholderCreated"),s(" 修改它. 如果想操作此元素比如添加文字, 只能通过原生 js 操作.")],-1),ce=s("拖拽到节点上时打开该节点"),ge=s("当把节点拖动到一个折叠节点上时, 默认会打开此节点以便拖入其中. 可通过 prop "),fe=i("code",null,"unfoldWhenDragover",-1),ve=s("控制. 相关 prop: "),he=s("unfoldWhenDragoverDelay"),me=s("拖拽节点的定位"),xe=s("默认使用拖拽节点的左上角坐标来定位, 也可以设置使用鼠标位置来定位. "),De=s("draggingNodePositionMode"),_e=s("边缘滚动"),qe=s("这是属于拖拽插件的功能. 如果树处在一个滚动框中, 拖拽到其边缘时需要自动滚动. 此项默认关闭, 使用 prop"),ye=i("code",null,"edgeScroll",-1),Te=s("开启. 相关 prop: "),be=s("edgeScrollTriggerMargin"),$e=s(", "),Ne=s("edgeScrollSpeed"),Be=s(", "),Le=s("edgeScrollTriggerMode"),Me=s("."),Se=s("触摸"),Ke=i("p",null,[s("支持触摸设备. 触摸拖拽时将会阻止默认行为, 但是有时无效. 所以请添加如下 css 阻止触摸时的默认行为例如滚动屏幕. css 目标是触发拖拽的元素. 如果未特别指定触发拖拽的元素, 则由"),i("code",null,"tree-node"),s("触发.")],-1),Ce=i("pre",null,[i("code",{class:"language-css"},"touch-action: none;\n")],-1),He=s("最大层级"),Ve=i("p",null,[s("拖拽时限制树的最大层级. 可使用 prop "),i("code",null,"eachDroppable"),s(". 下面示例代码支持 Vue2 和 Vue3.")],-1),je=i("pre",null,[i("code",{class:"language-html"},'<Draggable :eachDroppable="eachDroppable" />\n')],-1),Pe=i("pre",null,[i("code",{class:"language-js"},'data() {\n  return {\n    eachDroppable: (node, store, options, startTree) => {\n      const maxLevel = 3; // 按你需要修改\n      let draggingNodeMaxLevel = 0;\n      hp.walkTreeData(\n        store.draggingNode,\n        (childNode) => {\n          if (childNode.$level > draggingNodeMaxLevel) {\n            draggingNodeMaxLevel = childNode.$level;\n          }\n        },\n        "$children"\n      );\n      draggingNodeMaxLevel = draggingNodeMaxLevel - store.draggingNode.$level;\n      if (node.$level + draggingNodeMaxLevel >= maxLevel) {\n        return false;\n      }\n    },\n  }\n}\n')],-1),ke=s("Pro 插件(需购买)"),Ie=s("pro 插件"),ze=s(" 有以下高级功能."),Fe=i("ul",null,[i("li",null,"跨树拖拽."),i("li",null,"拖拽开始时克隆原节点而不是移动原节点.")],-1),We=s("通过 script 标签引入"),we=i("p",null,[s("从 npm 下载最新版本, 上传 "),i("code",null,"dist"),s(" 文件夹到你的服务器.")],-1),Ae=i("pre",null,[i("code",{class:"language-html"},'\x3c!-- replace vue3 to vue2 if use Vue2 --\x3e\n<script src="yourpath/dist/he-tree-vue3.min.js" charset="utf-8"><\/script>\n<link rel="stylesheet" href="yourpath/dist/he-tree-vue3.css" />\n\x3c!-- usage --\x3e\n<script type="text/javascript">\n  var Tree = heTreeVue3.BaseTree;\n  var Fold = heTreeVue3.Draggable;\n  ...\n<\/script>\n')],-1),Ge=i("p",null,[s("通过全局变量 "),i("code",null,"heTreeVue3"),s(" 或 "),i("code",null,"heTreeVue2"),s(" 访问此库.")],-1);g.render=function(e,l,d,n,t,s){const c=o("vheading"),g=o("Anchor");return a(),r("div",f,[i("div",v,[u(c,{level:1,id:"guide"},{default:p((()=>[h])),_:1}),m,u(c,{level:2,id:"安装"},{default:p((()=>[x])),_:1}),D,u(c,{level:2,id:"引入"},{default:p((()=>[_])),_:1}),q,u(c,{level:2,id:"不要给节点设置外边距"},{default:p((()=>[y])),_:1}),T,u(c,{level:2,id:"treedata-或-flatdata"},{default:p((()=>[b])),_:1}),$,u(c,{level:2,id:"html-结构"},{default:p((()=>[N])),_:1}),B,u(c,{level:2,id:"使用"},{default:p((()=>[L])),_:1}),M,u(c,{level:2,id:"输出数据"},{default:p((()=>[S])),_:1}),i("p",null,[K,C,H,V,j,u(g,{to:e.resolveHref("api.md#drop")},{default:p((()=>[P])),_:1},8,["to"]),k,u(g,{to:e.resolveHref("api.md#drop-change")},{default:p((()=>[I])),_:1},8,["to"]),z]),u(c,{level:2,id:"折叠和展开"},{default:p((()=>[F])),_:1}),W,u(c,{level:2,id:"按需加载子节点"},{default:p((()=>[w])),_:1}),A,u(c,{level:2,id:"默认折叠所有节点"},{default:p((()=>[G])),_:1}),R,u(c,{level:2,id:"勾选框"},{default:p((()=>[E])),_:1}),J,O,u(c,{level:2,id:"rtl"},{default:p((()=>[Q])),_:1}),U,u(c,{level:2,id:"虚拟列表"},{default:p((()=>[X])),_:1}),Y,u(c,{level:2,id:"拖拽"},{default:p((()=>[Z])),_:1}),ee,u(c,{level:2,id:"拖拽触发"},{default:p((()=>[le])),_:1}),de,u(c,{level:2,id:"阻止拖拽"},{default:p((()=>[ne])),_:1}),te,u(c,{level:2,id:"阻止放入"},{default:p((()=>[oe])),_:1}),ae,u(c,{level:2,id:"拖拽过程中的运行时数据"},{default:p((()=>[re])),_:1}),i("p",null,[ie,u(g,{to:e.resolveHref("api.md#store")},{default:p((()=>[ue])),_:1},8,["to"])]),u(c,{level:2,id:"占位元素"},{default:p((()=>[pe])),_:1}),se,u(c,{level:2,id:"拖拽到节点上时打开该节点"},{default:p((()=>[ce])),_:1}),i("p",null,[ge,fe,ve,u(g,{to:e.resolveHref("api.md#unfoldWhenDragoverDelay")},{default:p((()=>[he])),_:1},8,["to"])]),u(c,{level:2,id:"拖拽节点的定位"},{default:p((()=>[me])),_:1}),i("p",null,[xe,u(g,{to:e.resolveHref("api.md#draggingNodePositionMode")},{default:p((()=>[De])),_:1},8,["to"])]),u(c,{level:2,id:"边缘滚动"},{default:p((()=>[_e])),_:1}),i("p",null,[qe,ye,Te,u(g,{to:e.resolveHref("api.md#edgeScrollTriggerMargin")},{default:p((()=>[be])),_:1},8,["to"]),$e,u(g,{to:e.resolveHref("api.md#edgeScrollSpeed")},{default:p((()=>[Ne])),_:1},8,["to"]),Be,u(g,{to:e.resolveHref("api.md#edgeScrollTriggerMode")},{default:p((()=>[Le])),_:1},8,["to"]),Me]),u(c,{level:2,id:"触摸"},{default:p((()=>[Se])),_:1}),Ke,Ce,u(c,{level:2,id:"最大层级"},{default:p((()=>[He])),_:1}),Ve,je,Pe,u(c,{level:2,id:"pro-插件需购买"},{default:p((()=>[ke])),_:1}),i("p",null,[u(g,{to:e.resolveHref("/pro-plugin")},{default:p((()=>[Ie])),_:1},8,["to"]),ze]),Fe,u(c,{level:2,id:"通过-script-标签引入"},{default:p((()=>[We])),_:1}),we,Ae,Ge])])};export{g as default};

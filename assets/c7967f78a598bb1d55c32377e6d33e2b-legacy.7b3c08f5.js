System.register(["./index-legacy.d3df9ce4.js","./DocTemplateBase-legacy.6da93aea.js","./vendor-legacy.95c2d8ab.js"],(function(e){"use strict";var l,d,n,t,o,a,r,i,u,c,p,s,g;return{setters:[function(e){l=e.u,d=e.d},function(e){n=e._},function(e){t=e.h,o=e.I,a=e.k,r=e.v,i=e.n,u=e.t,c=e.p,p=e.w,s=e.z,g=e.W}],execute:function(){const f=e("default",{extends:n,setup(){const e=o(),n=[{name:"安装",id:"安装",children:[]},{name:"引入",id:"引入",children:[]},{name:"不要给节点设置外边距",id:"不要给节点设置外边距",children:[]},{name:"treeData 或 flatData",id:"treedata-或-flatdata",children:[]},{name:"HTML 结构",id:"html-结构",children:[]},{name:"使用",id:"使用",children:[]},{name:"输出数据",id:"输出数据",children:[]},{name:"折叠和展开",id:"折叠和展开",children:[]},{name:"按需加载子节点",id:"按需加载子节点",children:[]},{name:"默认折叠所有节点",id:"默认折叠所有节点",children:[]},{name:"勾选框",id:"勾选框",children:[]},{name:"RTL",id:"rtl",children:[]},{name:"虚拟列表",id:"虚拟列表",children:[]},{name:"拖拽",id:"拖拽",children:[]},{name:"拖拽触发",id:"拖拽触发",children:[]},{name:"阻止拖拽",id:"阻止拖拽",children:[]},{name:"阻止放入",id:"阻止放入",children:[]},{name:"拖拽过程中的运行时数据",id:"拖拽过程中的运行时数据",children:[]},{name:"占位元素",id:"占位元素",children:[]},{name:"拖拽到节点上时打开该节点",id:"拖拽到节点上时打开该节点",children:[]},{name:"拖拽节点的定位",id:"拖拽节点的定位",children:[]},{name:"边缘滚动",id:"边缘滚动",children:[]},{name:"触摸",id:"触摸",children:[]},{name:"最大层级",id:"最大层级",children:[]},{name:"Pro 插件(需购买)",id:"pro-插件需购买",children:[]},{name:"通过 script 标签引入",id:"通过-script-标签引入",children:[]}];l("Guide",e),d.value=n,t((()=>{d.value=null}))}}),v={class:"docs-view"},h={class:"article mt-14 mb-8 prose"},m=s("Guide"),x=u("p",null,[u("strong",null,"使用 Vue2 时把下面文档的 3 替换为 2.")],-1),D=s("安装"),_=u("pre",null,[u("code",{class:"language-sh"},"# Vue3\nnpm i -P @he-tree/vue3\n# Vue2\nnpm i -P @he-tree/vue2\n")],-1),y=s("引入"),q=u("pre",null,[u("code",{class:"language-ts"},"import { BaseTree, Draggable, obj, BaseNode, Node } from '@he-tree/vue3'\nimport '@he-tree/vue3/dist/he-tree-vue3.css'\n")],-1),T=s("不要给节点设置外边距"),b=u("p",null,[s("你可能需要设置节点之间的距离, 不要使用"),u("code",null,"margin-bottom"),s("来实现. 否则组件不能得到节点的真实高度. 使用 prop "),u("code",null,"gap"),s(" 替代.")],-1),$=s("treeData 或 flatData"),N=g('<p>该组件可以传入树形数据或扁平数据. 传入树形数据(treeData)时, 需指定 <code>childrenKey</code>. 传入扁平数据(flatData)时, 需指定 <code>idKey</code>, <code>parentIdKey</code>.</p><p><code>treeData</code> 示例:</p><pre><code class="language-ts">treeData = [\n  {\n    text: &#39;node1&#39;,\n    children: [{ text: &#39;node1-1&#39; }, { text: &#39;node1-2&#39; }, { text: &#39;node1-3&#39; }],\n  },\n  { text: &#39;node2&#39; },\n]\n</code></pre><p><code>flatData</code> 示例:</p><pre><code class="language-ts">flatData = [\n  { text: &#39;node1&#39;, id: 1 },\n  { text: &#39;node2&#39;, id: 2 },\n  { text: &#39;node1-1&#39;, id: 3, pid: 1 },\n  { text: &#39;node1-2&#39;, id: 3, pid: 1 },\n  { text: &#39;node1-3&#39;, id: 3, pid: 1 },\n]\n</code></pre>',5),B=s("HTML 结构"),L=g('<pre><code class="language-pug">.he-tree(:id=&quot;treeID&quot; :class=&quot;{&#39;he-tree-dragging&#39;:dragging, &#39;he-tree-rtl&#39;: rtl}&quot;)\n  .vl-items\n    .tree-node-outer(:data-id=&quot;node.$id&quot; :class=&quot;node.$outerClass&quot; :style=&quot;node.$outerClass&quot;)\n      .tree-node(:class=&quot;node.$nodeClass&quot; :style=&quot;node.$nodeStyle&quot;)\n        slot(:node=&quot;node&quot; :tree=&quot;tree&quot;) {{node[textKey]}}\n    .tree-node-outer(:data-id=&quot;node.$id&quot; :class=&quot;node.$outerClass&quot; :style=&quot;node.$outerClass&quot;)\n      .tree-node(:class=&quot;node.$nodeClass&quot; :style=&quot;node.$nodeStyle&quot;)\n        slot(:node=&quot;node&quot; :tree=&quot;tree&quot;) {{node[textKey]}}\n    ...\n</code></pre><p><strong>该组件渲染为列表而不是树形结构. 不同层级的节点有不同的 <code>padding-left</code>.</strong> 参考此结构, 你可以做下面的事:</p><ul><li>设置 <code>node.$outerClass</code> 和 <code>node.$outerStyle</code>来控制 tree-node-outer 元素 的 class 和 style.</li><li>设置 <code>node.$nodeClass</code> 和 <code>node.$nodeStyle</code>来控制 tree-node 元素 的 class 和 style.</li><li>使用默认插槽来定制节点外观. 该插槽参数: node, tree.</li></ul>',3),S=s("使用"),M=u("pre",null,[u("code",{class:"language-vue"},"<template>\n  <BaseTree :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\" />\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { BaseTree } from '@he-tree/vue3'\n\n  export default {\n    components: { BaseTree },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n")],-1),K=s("输出数据"),C=s("使用方法 "),H=u("code",null,"outputNestedData",-1),V=s(" 和 "),j=u("code",null,"outputFlatData",-1),P=s(" 以获得树形数据或扁平数据. 在拖拽时为了获得改变后的数据, 可以在"),k=u("code",null,"drop",-1),I=s(" 或 "),z=u("code",null,"drop-change",-1),F=s("事件中执行它们."),W=s("折叠和展开"),w=u("pre",null,[u("code",{class:"language-vue"},"<template>\n  <BaseTree :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\">\n    <template v-slot=\"{ node, tree }\">\n      <b @click=\"tree.toggleFold(node)\">{{ node.$folded ? '+' : '-' }}</b>\n      <span>{{ node.text }}</span>\n    </template>\n  </BaseTree>\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { BaseTree } from '@he-tree/vue3'\n\n  export default {\n    components: { BaseTree },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n")],-1),A=s("按需加载子节点"),G=u("p",null,[s("展开节点时加载其子节点数据. 例如通过 Ajax. 使用 prop "),u("code",null,"childrenLazyLoading"),s(" 启用. prop "),u("code",null,"childrenLoader"),s(" 是加载时调用的方法, 可以返回 "),u("code",null,"Promise"),s(", 返回的数据只能是树形数据.")],-1),R=s("默认折叠所有节点"),E=u("p",null,[s("使用 prop "),u("code",null,"defaultFolded"),s(" 控制.")],-1),J=s("勾选框"),O=u("p",null,[s("使用方法 "),u("code",null,"getAllCheckedNodes"),s(" 以获得所有勾选的节点.")],-1),Q=u("pre",null,[u("code",{class:"language-vue"},"<template>\n  <BaseTree :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\">\n    <template v-slot=\"{ node, tree }\">\n      <input\n        type=\"checkbox\"\n        v-model=\"node.$checked\"\n        @change=\"tree.updateChecked(node)\"\n      />\n      <span>{{ node.text }}</span>\n    </template>\n  </BaseTree>\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { BaseTree } from '@he-tree/vue3'\n\n  export default {\n    components: { BaseTree },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n")],-1),U=s("RTL"),X=u("p",null,[s("从右到左显示. 使用 prop "),u("code",null,"rtl"),s(" 控制.")],-1),Y=s("虚拟列表"),Z=u("p",null,[s("此功能可以在有许多节点时提高渲染性能. 使用 prop "),u("code",null,"virtualization"),s(" 启用. 使用 prop "),u("code",null,"virtualizationPrerender"),s(" 设置开始时显示的节点数量.")],-1),ee=s("拖拽"),le=u("pre",null,[u("code",{class:"language-vue"},"<template>\n  <Draggable :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\" />\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { Draggable } from '@he-tree/vue3'\n\n  export default {\n    components: { Draggable },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n")],-1),de=s("拖拽触发"),ne=u("p",null,[s("使用 prop "),u("code",null,"triggerClass"),s(" 指定触发拖拽的元素的 css class. 当 prop "),u("code",null,"triggerBySelf"),s(" 为 true 时, 它的子元素将不能触发拖拽.")],-1),te=s("阻止拖拽"),oe=g("<ul><li>当 prop <code>draggable</code> 为 false, 此树的任一节点不能被拖拽.</li><li>使用 prop <code>eachDraggable</code> 在拖拽开始时.</li><li>当 prop <code>rootDraggable</code> 为 false, 顶级节点(level 1) 不能被拖拽.</li><li>使用 prop <code>ondragstart</code> 在拖拽开始时.</li><li>设置 <code>node.$draggable</code> 为 false 控制单个节点是否可拖拽.</li><li>当父节点不可拖拽而子节点可拖拽时, 例如设置 子节点的 <code>$draggable</code> 为 true, 子节点可以拖拽.</li></ul>",1),ae=s("阻止放入"),re=g("<ul><li>当 prop <code>droppable</code> 为 false, 任一节点不能放入这棵树.</li><li>使用 prop <code>eachDroppable</code> 当拖动到一节点上时.</li><li>当 prop <code>rootDroppable</code> 为 false, 被拖拽的节点不能成为顶级节点.</li><li>使用 prop <code>ondragend</code> 在拖拽结束时, 若返回 false, 则恢复拖拽前的原状. 支持 promise.</li><li>设置 <code>node.$droppable</code> 为 false 控制单个节点是否可放入.</li><li>当父节点不可放入而子节点可放入时, 例如设置子节点的 <code>$droppable</code> 为 true, 则此子节点可放入.</li></ul>",1),ie=s("拖拽过程中的运行时数据"),ue=s("参考 "),ce=u("code",null,"tree.store",-1),pe=s("占位元素"),se=u("p",null,[s("拖拽时, 会生成一个元素默认淡青色背景, 用以标识可放置的位置. 使用 prop "),u("code",null,"afterPlaceholderCreated"),s(" 修改它. 如果想操作此元素比如添加文字, 只能通过原生 js 操作.")],-1),ge=s("拖拽到节点上时打开该节点"),fe=s("当把节点拖动到一个折叠节点上时, 默认会打开此节点以便拖入其中. 可通过 prop "),ve=u("code",null,"unfoldWhenDragover",-1),he=s("控制. 相关 prop: "),me=s("unfoldWhenDragoverDelay"),xe=s("拖拽节点的定位"),De=s("默认使用拖拽节点的左上角坐标来定位, 也可以设置使用鼠标位置来定位. "),_e=s("draggingNodePositionMode"),ye=s("边缘滚动"),qe=s("这是属于拖拽插件的功能. 如果树处在一个滚动框中, 拖拽到其边缘时需要自动滚动. 此项默认关闭, 使用 prop"),Te=u("code",null,"edgeScroll",-1),be=s("开启. 相关 prop: "),$e=s("edgeScrollTriggerMargin"),Ne=s(", "),Be=s("edgeScrollSpeed"),Le=s(", "),Se=s("edgeScrollTriggerMode"),Me=s("."),Ke=s("触摸"),Ce=u("p",null,[s("支持触摸设备. 触摸拖拽时将会阻止默认行为, 但是有时无效. 所以请添加如下 css 阻止触摸时的默认行为例如滚动屏幕. css 目标是触发拖拽的元素. 如果未特别指定触发拖拽的元素, 则由"),u("code",null,"tree-node"),s("触发.")],-1),He=u("pre",null,[u("code",{class:"language-css"},"touch-action: none;\n")],-1),Ve=s("最大层级"),je=u("p",null,[s("拖拽时限制树的最大层级. 可使用 prop "),u("code",null,"eachDroppable"),s(". 下面示例代码支持 Vue2 和 Vue3.")],-1),Pe=u("pre",null,[u("code",{class:"language-html"},'<Draggable :eachDroppable="eachDroppable" />\n')],-1),ke=u("pre",null,[u("code",{class:"language-js"},'data() {\n  return {\n    eachDroppable: (node, store, options, startTree) => {\n      const maxLevel = 3; // 按你需要修改\n      let draggingNodeMaxLevel = 0;\n      hp.walkTreeData(\n        store.draggingNode,\n        (childNode) => {\n          if (childNode.$level > draggingNodeMaxLevel) {\n            draggingNodeMaxLevel = childNode.$level;\n          }\n        },\n        "$children"\n      );\n      draggingNodeMaxLevel = draggingNodeMaxLevel - store.draggingNode.$level;\n      if (node.$level + draggingNodeMaxLevel >= maxLevel) {\n        return false;\n      }\n    },\n  }\n}\n')],-1),Ie=s("Pro 插件(需购买)"),ze=s("pro 插件"),Fe=s(" 有以下高级功能."),We=u("ul",null,[u("li",null,"跨树拖拽."),u("li",null,"拖拽开始时克隆原节点而不是移动原节点.")],-1),we=s("通过 script 标签引入"),Ae=u("p",null,[s("从 npm 下载最新版本, 上传 "),u("code",null,"dist"),s(" 文件夹到你的服务器.")],-1),Ge=u("pre",null,[u("code",{class:"language-html"},'\x3c!-- replace vue3 to vue2 if use Vue2 --\x3e\n<script src="yourpath/dist/he-tree-vue3.min.js" charset="utf-8"><\/script>\n<link rel="stylesheet" href="yourpath/dist/he-tree-vue3.css" />\n\x3c!-- usage --\x3e\n<script type="text/javascript">\n  var Tree = heTreeVue3.BaseTree;\n  var Fold = heTreeVue3.Draggable;\n  ...\n<\/script>\n')],-1),Re=u("p",null,[s("通过全局变量 "),u("code",null,"heTreeVue3"),s(" 或 "),u("code",null,"heTreeVue2"),s(" 访问此库.")],-1);f.render=function(e,l,d,n,t,o){const s=a("vheading"),g=a("Anchor");return r(),i("div",v,[u("div",h,[c(s,{level:1,id:"guide"},{default:p((()=>[m])),_:1}),x,c(s,{level:2,id:"安装"},{default:p((()=>[D])),_:1}),_,c(s,{level:2,id:"引入"},{default:p((()=>[y])),_:1}),q,c(s,{level:2,id:"不要给节点设置外边距"},{default:p((()=>[T])),_:1}),b,c(s,{level:2,id:"treedata-或-flatdata"},{default:p((()=>[$])),_:1}),N,c(s,{level:2,id:"html-结构"},{default:p((()=>[B])),_:1}),L,c(s,{level:2,id:"使用"},{default:p((()=>[S])),_:1}),M,c(s,{level:2,id:"输出数据"},{default:p((()=>[K])),_:1}),u("p",null,[C,H,V,j,P,c(g,{to:e.resolveHref("api.md#drop")},{default:p((()=>[k])),_:1},8,["to"]),I,c(g,{to:e.resolveHref("api.md#drop-change")},{default:p((()=>[z])),_:1},8,["to"]),F]),c(s,{level:2,id:"折叠和展开"},{default:p((()=>[W])),_:1}),w,c(s,{level:2,id:"按需加载子节点"},{default:p((()=>[A])),_:1}),G,c(s,{level:2,id:"默认折叠所有节点"},{default:p((()=>[R])),_:1}),E,c(s,{level:2,id:"勾选框"},{default:p((()=>[J])),_:1}),O,Q,c(s,{level:2,id:"rtl"},{default:p((()=>[U])),_:1}),X,c(s,{level:2,id:"虚拟列表"},{default:p((()=>[Y])),_:1}),Z,c(s,{level:2,id:"拖拽"},{default:p((()=>[ee])),_:1}),le,c(s,{level:2,id:"拖拽触发"},{default:p((()=>[de])),_:1}),ne,c(s,{level:2,id:"阻止拖拽"},{default:p((()=>[te])),_:1}),oe,c(s,{level:2,id:"阻止放入"},{default:p((()=>[ae])),_:1}),re,c(s,{level:2,id:"拖拽过程中的运行时数据"},{default:p((()=>[ie])),_:1}),u("p",null,[ue,c(g,{to:e.resolveHref("api.md#store")},{default:p((()=>[ce])),_:1},8,["to"])]),c(s,{level:2,id:"占位元素"},{default:p((()=>[pe])),_:1}),se,c(s,{level:2,id:"拖拽到节点上时打开该节点"},{default:p((()=>[ge])),_:1}),u("p",null,[fe,ve,he,c(g,{to:e.resolveHref("api.md#unfoldWhenDragoverDelay")},{default:p((()=>[me])),_:1},8,["to"])]),c(s,{level:2,id:"拖拽节点的定位"},{default:p((()=>[xe])),_:1}),u("p",null,[De,c(g,{to:e.resolveHref("api.md#draggingNodePositionMode")},{default:p((()=>[_e])),_:1},8,["to"])]),c(s,{level:2,id:"边缘滚动"},{default:p((()=>[ye])),_:1}),u("p",null,[qe,Te,be,c(g,{to:e.resolveHref("api.md#edgeScrollTriggerMargin")},{default:p((()=>[$e])),_:1},8,["to"]),Ne,c(g,{to:e.resolveHref("api.md#edgeScrollSpeed")},{default:p((()=>[Be])),_:1},8,["to"]),Le,c(g,{to:e.resolveHref("api.md#edgeScrollTriggerMode")},{default:p((()=>[Se])),_:1},8,["to"]),Me]),c(s,{level:2,id:"触摸"},{default:p((()=>[Ke])),_:1}),Ce,He,c(s,{level:2,id:"最大层级"},{default:p((()=>[Ve])),_:1}),je,Pe,ke,c(s,{level:2,id:"pro-插件需购买"},{default:p((()=>[Ie])),_:1}),u("p",null,[c(g,{to:e.resolveHref("/pro-plugin")},{default:p((()=>[ze])),_:1},8,["to"]),Fe]),We,c(s,{level:2,id:"通过-script-标签引入"},{default:p((()=>[we])),_:1}),Ae,Ge,Re])])}}}}));
